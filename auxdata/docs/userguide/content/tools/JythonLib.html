[ug::head {Jython Library}]

<a name="grid">
<h2> Module: grid</h2>
 This is the doc for the grid module 
<hr>

<meta name="jhid" value="GP2Z">
<p><a name="GP2Z"></a><code class="command">GP2Z(gp):</code><p style="padding:0;margin-left:20;margin-top:0">
Convert Geopotential (GP) to Height (Z)</p>
<meta name="jhid" value="applyToRange">
<p><a name="applyToRange"></a><code class="command">applyToRange(function, data):</code><p style="padding:0;margin-left:20;margin-top:0">
Apply the function name to each timestep of the data</p>
<meta name="jhid" value="applyToRangeValues">
<p><a name="applyToRangeValues"></a><code class="command">applyToRangeValues(function, data):</code><p style="padding:0;margin-left:20;margin-top:0">
Apply the function name to each value in each timestep of the data</p>
<meta name="jhid" value="averageOverTime">
<p><a name="averageOverTime"></a><code class="command">averageOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
Average the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the average</p>
<meta name="jhid" value="combineFields">
<p><a name="combineFields"></a><code class="command">combineFields():</code><p style="padding:0;margin-left:20;margin-top:0">
combine several fields together</p>
<meta name="jhid" value="differenceFromBaseTime">
<p><a name="differenceFromBaseTime"></a><code class="command">differenceFromBaseTime(field):</code><p style="padding:0;margin-left:20;margin-top:0">
set the value of each time step N:
D(N)= D(N) - D(0)</p>
<meta name="jhid" value="exportGridToNetcdf">
<p><a name="exportGridToNetcdf"></a><code class="command">exportGridToNetcdf(grid, filename):</code><p style="padding:0;margin-left:20;margin-top:0">
Write out the grid data to CF compliant netCDF file</p>
<meta name="jhid" value="extractLatitudeFromNWPGrid">
<p><a name="extractLatitudeFromNWPGrid"></a><code class="command">extractLatitudeFromNWPGrid(fieldimpl):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the latitude coordinate from a grid.  Return a grid
of the latitudes at each point.</p>
<meta name="jhid" value="extractLongitudeFromNWPGrid">
<p><a name="extractLongitudeFromNWPGrid"></a><code class="command">extractLongitudeFromNWPGrid(fieldimpl):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the longitude coordinate from a grid.  Return a grid
of the longitudes at each point.</p>
<meta name="jhid" value="extractPressureFromNWPGrid">
<p><a name="extractPressureFromNWPGrid"></a><code class="command">extractPressureFromNWPGrid(fieldimpl):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the pressure coordinate from a time series grid and
return a grid of the pressure at all points.  Input
grid must have pressure or height (which is converted
to pressure in the standard atmosphere).
User must be sure input is a suitable FlatField.</p>
<meta name="jhid" value="getAltitude">
<p><a name="getAltitude"></a><code class="command">getAltitude(z):</code><p style="padding:0;margin-left:20;margin-top:0">
Change units from geopotential meters to meters</p>
<meta name="jhid" value="getNthTimeGrid">
<p><a name="getNthTimeGrid"></a><code class="command">getNthTimeGrid(fieldimpl, Nth):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the Nth grid in time series of grids;
User must be sure input is a suitable data field.
returns a single time.
Nth is an integer, >=0, <= max index of grid time series.</p>
<meta name="jhid" value="getSliceAtAltitude">
<p><a name="getSliceAtAltitude"></a><code class="command">getSliceAtAltitude(fieldimpl, alt, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Extract a 2D horizontal slice from a 3D grid at the given altitude;
level is a real number; if unit is supplied, it must
be compatible with meters (ft, fathoms, etc)
param fieldimpl is a grid which may have
one or more time steps.</p>
<meta name="jhid" value="getSliceAtLevel">
<p><a name="getSliceAtLevel"></a><code class="command">getSliceAtLevel(fieldimpl, level):</code><p style="padding:0;margin-left:20;margin-top:0">
Extract a 2D horizontal slice from a 3D grid at "Level."
level is a real number; must be appropriate for the grid.
param fieldimpl is a grid which may have one or more time steps.</p>
<meta name="jhid" value="horizontalAdvection">
<p><a name="horizontalAdvection"></a><code class="command">horizontalAdvection(param, u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
horizontal advection</p>
<meta name="jhid" value="horizontalDivergence">
<p><a name="horizontalDivergence"></a><code class="command">horizontalDivergence(param, u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
horizontal flux divergence</p>
<meta name="jhid" value="layerAverage">
<p><a name="layerAverage"></a><code class="command">layerAverage(grid, top, bottom, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for calculating layer average</p>
<meta name="jhid" value="layerDiff">
<p><a name="layerDiff"></a><code class="command">layerDiff(grid, top, bottom, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for calculating layer difference</p>
<meta name="jhid" value="lonFlip">
<p><a name="lonFlip"></a><code class="command">lonFlip(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
Flip the longitudes in a grid from -180-180 to 0-360 (or vice-versa).
Only works for cyclic rectilinear grids.</p>
<meta name="jhid" value="make2D">
<p><a name="make2D"></a><code class="command">make2D(slice):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a 2D slice from a 3D slice at a single level</p>
<meta name="jhid" value="makeFlowField">
<p><a name="makeFlowField"></a><code class="command">makeFlowField(a, b, c):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from 3 components
<div class=jython>
makeVector(a,b,c) = \[a,b,c\]
</div></p>
<meta name="jhid" value="makeTimeSequence">
<p><a name="makeTimeSequence"></a><code class="command">makeTimeSequence(g):</code><p style="padding:0;margin-left:20;margin-top:0">
Merge a set of single time grids/images into a time sequence</p>
<meta name="jhid" value="makeTopographyFromField">
<p><a name="makeTopographyFromField"></a><code class="command">makeTopographyFromField(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
make a topography out of a grid</p>
<meta name="jhid" value="makeTrueVector">
<p><a name="makeTrueVector"></a><code class="command">makeTrueVector(u, v):</code><p style="padding:0;margin-left:20;margin-top:0">
true wind vectors</p>
<meta name="jhid" value="makeVector">
<p><a name="makeVector"></a><code class="command">makeVector(a, b):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from 2 components
<div class=jython>
makeVector(a,b) = \[a,b\]
</div></p>
<meta name="jhid" value="maskGrid">
<p><a name="maskGrid"></a><code class="command">maskGrid(grid, mask, value, resample):</code><p style="padding:0;margin-left:20;margin-top:0">
mask one grid by the values in the other.  value is the masking value</p>
<meta name="jhid" value="maxOverTime">
<p><a name="maxOverTime"></a><code class="command">maxOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the max of the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the max</p>
<meta name="jhid" value="mergeTimeSequences">
<p><a name="mergeTimeSequences"></a><code class="command">mergeTimeSequences(g):</code><p style="padding:0;margin-left:20;margin-top:0">
Merge a set of time sequences of grids/images into a single time sequence.
All grids/images must have the same parameter name</p>
<meta name="jhid" value="minOverTime">
<p><a name="minOverTime"></a><code class="command">minOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the min of the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the min</p>
<meta name="jhid" value="newName">
<p><a name="newName"></a><code class="command">newName(field, varname, copy):</code><p style="padding:0;margin-left:20;margin-top:0">
create a new field with a new parameter name</p>
<meta name="jhid" value="newUnit">
<p><a name="newUnit"></a><code class="command">newUnit(field, varname, unitname):</code><p style="padding:0;margin-left:20;margin-top:0">
set the name and unit on a grid</p>
<meta name="jhid" value="noUnit">
<p><a name="noUnit"></a><code class="command">noUnit(field):</code><p style="padding:0;margin-left:20;margin-top:0">
remove the units from a grid</p>
<meta name="jhid" value="oldaverageOverTime">
<p><a name="oldaverageOverTime"></a><code class="command">oldaverageOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
@deprecated Average the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the average</p>
<meta name="jhid" value="resampleGrid">
<p><a name="resampleGrid"></a><code class="command">resampleGrid(oldGrid, gridwithNewDomain):</code><p style="padding:0;margin-left:20;margin-top:0">
display gridded data on a new domain</p>
<meta name="jhid" value="runave">
<p><a name="runave"></a><code class="command">runave(grid, nave, option):</code><p style="padding:0;margin-left:20;margin-top:0">
generate a running average:
<div class=jython>
Where:<br>
grid = grid to average<br>
nave - number of steps to average over<br>
option - option for unsmoothed end points<br>
0 - set to missing<br>
1 - use symmetry<br>
-1 - assume cyclic <br>
</div></p>
<meta name="jhid" value="substitute">
<p><a name="substitute"></a><code class="command">substitute(data, low, high, newValue):</code><p style="padding:0;margin-left:20;margin-top:0">
change values in data  between low/high to newvalue</p>
<meta name="jhid" value="sumFromBaseTime">
<p><a name="sumFromBaseTime"></a><code class="command">sumFromBaseTime(field):</code><p style="padding:0;margin-left:20;margin-top:0">
set the value of each time step N:
D(N)= D(N) + D(0)</p>
<meta name="jhid" value="sumOverTime">
<p><a name="sumOverTime"></a><code class="command">sumOverTime(field, makeTimes):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the sum of the values in each time step
If makeTimes is true (1) then we return a field mapping all of the times
to the average. Else we just return the sum</p>
<meta name="jhid" value="timeStepDifference">
<p><a name="timeStepDifference"></a><code class="command">timeStepDifference(field, offset):</code><p style="padding:0;margin-left:20;margin-top:0">
set the value of each time step N:
D(N)= D(N) - D(N+offset)
where offset should be negative</p>
<meta name="jhid" value="timeStepSum">
<p><a name="timeStepSum"></a><code class="command">timeStepSum(field, offset):</code><p style="padding:0;margin-left:20;margin-top:0">
set the value of each time step N:
D(N)= D(N) + D(N+offset)
where offset should be negative</p>
<meta name="jhid" value="uvFromWindDir">
<p><a name="uvFromWindDir"></a><code class="command">uvFromWindDir(dir):</code><p style="padding:0;margin-left:20;margin-top:0">
creating the vector field using the wind direction</p>
<meta name="jhid" value="wgt_runave">
<p><a name="wgt_runave"></a><code class="command">wgt_runave(grid, wgts, option):</code><p style="padding:0;margin-left:20;margin-top:0">
generate a weighted running average:
<div class=jython>
Where:<br>
grid = grid to average<br>
wgts - comma separated list of weights<br>
option - option for unsmoothed end points<br>
0 - set to missing<br>
1 - use symmetry<br>
-1 - assume cyclic <br>
</div></p>
<meta name="jhid" value="windShear">
<p><a name="windShear"></a><code class="command">windShear(u, v, z, top, bottom, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the wind shear between discrete layers
<div class=jython>
shear = sqrt((u(top)-u(bottom))^2 + (v(top)-v(bottom))^2)/zdiff</pre>
</div></p>
<meta name="jhid" value="windShearVector">
<p><a name="windShearVector"></a><code class="command">windShearVector(u, v, top, bottom, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the u and v layer difference and return as vector</p>
<meta name="jhid" value="writeGridToXls">
<p><a name="writeGridToXls"></a><code class="command">writeGridToXls(grid, filename):</code><p style="padding:0;margin-left:20;margin-top:0">
Write out the grid data to an excel spreadsheet</p>
<a name="griddiag">
<h2> Module: griddiag</h2>
 
   This is the doc for the Grid Diagnostics module.  These functions
   are based on the grid diagnostics from the GEneral Meteorological 
   PAcKage (GEMPAK).  Note that the names are case sensitive and some
   are named slightly different from GEMPAK functions to avoid conflicts
   with Jython built-ins (e.g. str).
   <P>
   In the following operators, scalar operands are named S<sub>n</sub> and 
   vector operands are named V<sub>n</sub>.  Lowercase u and v refer to the
   grid relative components of a vector.

<hr>

<meta name="jhid" value="GRAVITY">
<p><a name="GRAVITY"></a><code class="command">GRAVITY():</code><p style="padding:0;margin-left:20;margin-top:0">
Gravity constant</p>
<meta name="jhid" value="add">
<p><a name="add"></a><code class="command">add(S1, S2, WA):</code><p style="padding:0;margin-left:20;margin-top:0">
Addition
<div class=jython>
ADD  (S1, S2) = S1 + S2<br>
WA = use WEIGHTED_AVERAGE (default NEAREST_NEIGHBOR)
</div></p>
<meta name="jhid" value="adv">
<p><a name="adv"></a><code class="command">adv(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Advection, negative by convention
<div class=jython>
ADV ( S, V ) = - ( u * DDX (S) + v * DDY (S) )
</div></p>
<meta name="jhid" value="age">
<p><a name="age"></a><code class="command">age(obs, geo):</code><p style="padding:0;margin-left:20;margin-top:0">
Ageostrophic wind
<div class=jython>
AGE ( S ) = \[ u (OBS) - u (GEO(S)), v (OBS) - v (GEO(S)) \]
</div></p>
<meta name="jhid" value="atn2">
<p><a name="atn2"></a><code class="command">atn2(S1, S2, WA):</code><p style="padding:0;margin-left:20;margin-top:0">
Wrapper for atan2 built-in
<div class=jython>
ATN2 (S1, S2) = ATAN ( S1 / S2 )<br>
WA = use WEIGHTED_AVERAGE (default NEAREST_NEIGHBOR)
</div></p>
<meta name="jhid" value="avg">
<p><a name="avg"></a><code class="command">avg(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Average of 2 scalars
<div class=jython>
AVG  (S1, S2) = ( S1 + S2 ) / 2
</div></p>
<meta name="jhid" value="avor">
<p><a name="avor"></a><code class="command">avor(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Absolute Vorticity
<div class=jython>
AVOR ( V ) = VOR ( V ) + CORL(V)
</div></p>
<meta name="jhid" value="circs">
<p><a name="circs"></a><code class="command">circs(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a circular aperature smoothing to the grid points.  The weighting
function is the circular aperature diffraction function.  D is
the radius of influence in grid increments, increasing D increases
the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="circv">
<p><a name="circv"></a><code class="command">circv(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a circular aperature smoothing to the grid points.  The weighting
function is the circular aperature diffraction function.  D is
the radius of influence in grid increments, increasing D increases
the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="corl">
<p><a name="corl"></a><code class="command">corl(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Coriolis Parameter for all points in a grid
<div class=jython>
CORL = TWO_OMEGA*sin(latr)
</div></p>
<meta name="jhid" value="cress">
<p><a name="cress"></a><code class="command">cress(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a Cressman smoothing to the grid points.  The smoothed value
is given by a weighted average of surrounding grid points.  D is
the radius of influence in grid increments,
increasing D increases the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="cresv">
<p><a name="cresv"></a><code class="command">cresv(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a Cressman smoothing to the grid points.  The smoothed value
is given by a weighted average of surrounding grid points.  D is
the radius of influence in grid increments,
increasing D increases the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="cros">
<p><a name="cros"></a><code class="command">cros(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Vector cross product magnitude
<div class=jython>
CROS ( V1, V2 ) = u1 * v2 - u2 * v1
</div></p>
<meta name="jhid" value="ddx">
<p><a name="ddx"></a><code class="command">ddx(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the derivative with respect to the domain's X coordinate</p>
<meta name="jhid" value="ddy">
<p><a name="ddy"></a><code class="command">ddy(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Take the derivative with respect to the domain's Y coordinate</p>
<meta name="jhid" value="defr">
<p><a name="defr"></a><code class="command">defr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Total deformation
<div class=jython>
DEF ( V ) = ( STRD (V) ** 2 + SHR (V) ** 2 ) ** .5
</div></p>
<meta name="jhid" value="dirn">
<p><a name="dirn"></a><code class="command">dirn(V):</code><p style="padding:0;margin-left:20;margin-top:0">
North relative direction of a vector
<div class=jython>
DIRN ( V ) = DIRR ( un(v), vn(v) )
</div></p>
<meta name="jhid" value="dirr">
<p><a name="dirr"></a><code class="command">dirr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Grid relative direction of a vector</p>
<meta name="jhid" value="div">
<p><a name="div"></a><code class="command">div(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Divergence
<div class=jython>
DIV ( V ) = DDX ( u ) + DDY ( v )
</div></p>
<meta name="jhid" value="dot">
<p><a name="dot"></a><code class="command">dot(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Vector dot product
<div class=jython>
DOT ( V1, V2 ) = u1 * u2 + v1 * v2
</div></p>
<meta name="jhid" value="dvdx">
<p><a name="dvdx"></a><code class="command">dvdx(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Partial x derivative of a vector
<div class=jython>
DVDX ( V ) = \[ DDX (u), DDX (v) \]
</div></p>
<meta name="jhid" value="dvdy">
<p><a name="dvdy"></a><code class="command">dvdy(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Partial x derivative of a vector
<div class=jython>
DVDY ( V ) = \[ DDY (u), DDY (v) \]
</div></p>
<meta name="jhid" value="frnt">
<p><a name="frnt"></a><code class="command">frnt(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Frontogenesis function from theta and the wind
<div class=jython>
FRNT ( THTA, V ) = 1/2 * MAG ( GRAD (THTA) ) *
( DEF * COS (2 * BETA) - DIV )                <p>
Where: BETA = ASIN ( (-DDX (THTA) * COS (PSI) <br>
- DDY (THTA) * SIN (PSI))/   <br>
MAG ( GRAD (THTA) ) )           <br>
PSI  = 1/2 ATAN2 ( SHR / STR )         <br>
</div></p>
<meta name="jhid" value="geo">
<p><a name="geo"></a><code class="command">geo(z):</code><p style="padding:0;margin-left:20;margin-top:0">
geostrophic wind from height
<div class=jython>
GEO ( S )  = \[ - DDY (S) * const / CORL, DDX (S) * const / CORL \]
</div></p>
<meta name="jhid" value="grad">
<p><a name="grad"></a><code class="command">grad(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Gradient of a scalar
<div class=jython>
GRAD ( S ) = \[ DDX ( S ), DDY ( S ) \]
</div></p>
<meta name="jhid" value="gwfs">
<p><a name="gwfs"></a><code class="command">gwfs(S, N):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Horizontal smoothing using normally distributed weights
with theoretical response of 1/e for N * delta-x wave.
Increasing N increases the smoothing. (default N=6)
</div></p>
<meta name="jhid" value="gwfv">
<p><a name="gwfv"></a><code class="command">gwfv(V, N):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Horizontal smoothing using normally distributed weights
with theoretical response of 1/e for N * delta-x wave.
Increasing N increases the smoothing. (default N=6)
</div></p>
<meta name="jhid" value="inad">
<p><a name="inad"></a><code class="command">inad(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Inertial advective wind
<div class=jython>
INAD ( V1, V2 ) = \[ DOT ( V1, GRAD (u2) ),
DOT ( V1, GRAD (v2) ) \]
</div></p>
<meta name="jhid" value="jcbn">
<p><a name="jcbn"></a><code class="command">jcbn(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Jacobian Determinant
<div class=jython>
JCBN ( S1, S2 ) = DDX (S1) * DDY (S2) - DDY (S1) * DDX (S2)
</div></p>
<meta name="jhid" value="lap">
<p><a name="lap"></a><code class="command">lap(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Laplacian operator
<div class=jython>
LAP ( S ) = DIV ( GRAD (S) )
</div></p>
<meta name="jhid" value="latr">
<p><a name="latr"></a><code class="command">latr(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Latitudue all points in a grid</p>
<meta name="jhid" value="lav">
<p><a name="lav"></a><code class="command">lav(S, level1, level2, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Layer Average of a multi layer grid
<div class=jython>
LAV ( S ) = ( S (level1) + S (level2) ) / 2.
</div></p>
<meta name="jhid" value="ldf">
<p><a name="ldf"></a><code class="command">ldf(S, level1, level2, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Layer Difference
<div class=jython>
LDF ( S ) = S (level1) - S (level2)
</div></p>
<meta name="jhid" value="mag">
<p><a name="mag"></a><code class="command">mag():</code><p style="padding:0;margin-left:20;margin-top:0">
Magnitude of a vector</p>
<meta name="jhid" value="mixr">
<p><a name="mixr"></a><code class="command">mixr(temp, rh):</code><p style="padding:0;margin-left:20;margin-top:0">
Mixing Ratio from Temperature, RH (requires pressure domain)</p>
<meta name="jhid" value="mul">
<p><a name="mul"></a><code class="command">mul(S1, S2, WA):</code><p style="padding:0;margin-left:20;margin-top:0">
Multiply
<div class=jython>
MUL  (S1, S2) = S1 * S2<br>
WA = use WEIGHTED_AVERAGE (default NEAREST_NEIGHBOR)
</div></p>
<meta name="jhid" value="pvor">
<p><a name="pvor"></a><code class="command">pvor(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Potetial Vorticity (usually from theta and wind)</p>
<meta name="jhid" value="quo">
<p><a name="quo"></a><code class="command">quo(S1, S2, WA):</code><p style="padding:0;margin-left:20;margin-top:0">
Divide
<div class=jython>
QUO  (S1, S2) = S1 / S2<br>
WA = use WEIGHTED_AVERAGE (default NEAREST_NEIGHBOR)
</div></p>
<meta name="jhid" value="qvcl">
<p><a name="qvcl"></a><code class="command">qvcl(THTA, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Q-vector ( K / m / s )
<div class=jython>
QVCL ( THTA, V ) = ( 1/( D (THTA) / DP ) ) *
\[ ( DOT ( DVDX (V), GRAD (THTA) ) ),
( DOT ( DVDY (V), GRAD (THTA) ) ) \]
</div></p>
<meta name="jhid" value="qvec">
<p><a name="qvec"></a><code class="command">qvec(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Q-vector at a level ( K / m / s )
<div class=jython>
QVEC ( S, V ) = \[ - ( DOT ( DVDX (V), GRAD (S) ) ),
- ( DOT ( DVDY (V), GRAD (S) ) ) \]
where S can be any thermal paramenter, usually THTA.
</div></p>
<meta name="jhid" value="rects">
<p><a name="rects"></a><code class="command">rects(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a rectangular aperature smoothing to the grid points.  The weighting
function is the product of the rectangular aperature diffraction function
in the x and y directions.  D is the radius of influence in grid
increments, increasing D increases the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="rectv">
<p><a name="rectv"></a><code class="command">rectv(S, D):</code><p style="padding:0;margin-left:20;margin-top:0">
<div class=jython>
Apply a rectangular aperature smoothing to the grid points.  The weighting
function is the product of the rectangular aperature diffraction function
in the x and y directions.  D is the radius of influence in grid
increments, increasing D increases the smoothing. (default D=2)
</div></p>
<meta name="jhid" value="relh">
<p><a name="relh"></a><code class="command">relh(temp, mixr):</code><p style="padding:0;margin-left:20;margin-top:0">
Create Relative Humidity from Temperature, mixing ratio (requires pressure domain)</p>
<meta name="jhid" value="savg">
<p><a name="savg"></a><code class="command">savg(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Average over whole grid
<div class=jython>
SAVG ( S ) = average of all non-missing grid point values
</div></p>
<meta name="jhid" value="savs">
<p><a name="savs"></a><code class="command">savs(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Average over grid subset
<div class=jython>
SAVS ( S ) = average of all non-missing grid point values in the subset
area
</div></p>
<meta name="jhid" value="sdiv">
<p><a name="sdiv"></a><code class="command">sdiv(S, V):</code><p style="padding:0;margin-left:20;margin-top:0">
Horizontal Flux Divergence
<div class=jython>
SDIV ( S, V ) = S * DIV ( V ) + DOT ( V, GRAD ( S ) )
</div></p>
<meta name="jhid" value="shr">
<p><a name="shr"></a><code class="command">shr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Shear Deformation
<div class=jython>
SHR ( V ) = DDX ( v ) + DDY ( u )
</div></p>
<meta name="jhid" value="sm5s">
<p><a name="sm5s"></a><code class="command">sm5s(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Smooth a scalar grid using a 5-point smoother
<div class=jython>
SM5S ( S ) = .5 * S (i,j) + .125 * ( S (i+1,j) + S (i,j+1) +
S (i-1,j) + S (i,j-1) )
</div></p>
<meta name="jhid" value="sm5v">
<p><a name="sm5v"></a><code class="command">sm5v(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Smooth a scalar grid using a 5-point smoother (see sm5s)</p>
<meta name="jhid" value="sm9s">
<p><a name="sm9s"></a><code class="command">sm9s(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Smooth a scalar grid using a 9-point smoother
<div class=jython>
SM9S ( S ) = .25 * S (i,j) + .125 * ( S (i+1,j) + S (i,j+1) +
S (i-1,j) + S (i,j-1) )
+ .0625 * ( S (i+1,j+1) +
S (i+1,j-1) +
S (i-1,j+1) +
S (i-1,j-1) )
</div></p>
<meta name="jhid" value="sm9v">
<p><a name="sm9v"></a><code class="command">sm9v(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Smooth a scalar grid using a 9-point smoother (see sm9s)</p>
<meta name="jhid" value="strd">
<p><a name="strd"></a><code class="command">strd(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Stretching Deformation
<div class=jython>
STRD ( V ) = DDX ( u ) - DDY ( v )
</div></p>
<meta name="jhid" value="sub">
<p><a name="sub"></a><code class="command">sub(S1, S2, WA):</code><p style="padding:0;margin-left:20;margin-top:0">
Subtract
<div class=jython>
SUB  (S1, S2) = S1 - S2<br>
WA = use WEIGHTED_AVERAGE (default NEAREST_NEIGHBOR)
</div></p>
<meta name="jhid" value="thrm">
<p><a name="thrm"></a><code class="command">thrm(S, level1, level2, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Thermal wind
<div class=jython>
THRM ( S ) = \[ u (GEO(S)) (level1) - u (GEO(S)) (level2),
v (GEO(S)) (level1) - v (GEO(S)) (level2) \]
</div></p>
<meta name="jhid" value="thta">
<p><a name="thta"></a><code class="command">thta(temp):</code><p style="padding:0;margin-left:20;margin-top:0">
Potential Temperature from Temperature (requires pressure domain)</p>
<meta name="jhid" value="thte">
<p><a name="thte"></a><code class="command">thte(temp, rh):</code><p style="padding:0;margin-left:20;margin-top:0">
Equivalent Potential Temperature from Temperature and Relative
humidity (requires pressure domain)</p>
<meta name="jhid" value="un">
<p><a name="un"></a><code class="command">un(V):</code><p style="padding:0;margin-left:20;margin-top:0">
North relative u component</p>
<meta name="jhid" value="ur">
<p><a name="ur"></a><code class="command">ur(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Grid relative u component</p>
<meta name="jhid" value="vadd">
<p><a name="vadd"></a><code class="command">vadd(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
add the components of 2 vectors
<div class=jython>
VADD (V1, V2) = \[ u1+u2, v1+v2 \]
</div></p>
<meta name="jhid" value="vecn">
<p><a name="vecn"></a><code class="command">vecn(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a true nort vector from two components
<div class=jython>
VECN ( S1, S2 ) = \[ S1, S2 \]
</div></p>
<meta name="jhid" value="vecr">
<p><a name="vecr"></a><code class="command">vecr(S1, S2):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a vector from two components
<div class=jython>
VECR ( S1, S2 ) = \[ S1, S2 \]
</div></p>
<meta name="jhid" value="vlav">
<p><a name="vlav"></a><code class="command">vlav(V, level1, level2, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the vector layer average
<div class=jython>
VLDF(V) = \[(u(level1) - u(level2))/2,
(v(level1) - v(level2))/2\]
</div></p>
<meta name="jhid" value="vldf">
<p><a name="vldf"></a><code class="command">vldf(V, level1, level2, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
calculate the vector layer difference
<div class=jython>
VLDF(V) = \[u(level1) - u(level2),
v(level1) - v(level2)\]
</div></p>
<meta name="jhid" value="vmul">
<p><a name="vmul"></a><code class="command">vmul(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Multiply the components of 2 vectors
<div class=jython>
VMUL (V1, V2) = \[ u1*u2, v1*v2 \]
</div></p>
<meta name="jhid" value="vn">
<p><a name="vn"></a><code class="command">vn(V):</code><p style="padding:0;margin-left:20;margin-top:0">
North relative v component</p>
<meta name="jhid" value="vor">
<p><a name="vor"></a><code class="command">vor(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Relative Vorticity
<div class=jython>
VOR ( V ) = DDX ( v ) - DDY ( u )
</div></p>
<meta name="jhid" value="vquo">
<p><a name="vquo"></a><code class="command">vquo(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
Divide the components of 2 vectors
<div class=jython>
VQUO (V1, V2) = \[ u1/u2, v1/v2 \]
</div></p>
<meta name="jhid" value="vr">
<p><a name="vr"></a><code class="command">vr(V):</code><p style="padding:0;margin-left:20;margin-top:0">
Grid relative v component</p>
<meta name="jhid" value="vsub">
<p><a name="vsub"></a><code class="command">vsub(V1, V2):</code><p style="padding:0;margin-left:20;margin-top:0">
subtract the components of 2 vectors
<div class=jython>
VSUB (V1, V2) = \[ u1-u2, v1-v2 \]
</div></p>
<meta name="jhid" value="wshr">
<p><a name="wshr"></a><code class="command">wshr(V, Z, top, bottom):</code><p style="padding:0;margin-left:20;margin-top:0">
Magnitude of the vertical wind shear in a layer
<div class=jython>
WSHR ( V ) = MAG \[ VLDF (V) \] / LDF (Z)
</div></p>
<meta name="jhid" value="xav">
<p><a name="xav"></a><code class="command">xav(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Average along a grid row
<div class=jython>
XAV (S) = ( S (X1) + S (X2) + ... + S (KXD) ) / KNT
KXD = number of points in row
KNT = number of non-missing points in row
XAV for a row is stored at every point in that row.
</div></p>
<meta name="jhid" value="xsum">
<p><a name="xsum"></a><code class="command">xsum(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Sum along a grid row
<div class=jython>
XSUM (S) = ( S (X1) + S (X2) + ... + S (KXD) )
KXD = number of points in row
XSUM for a row is stored at every point in that row.
</div></p>
<meta name="jhid" value="yav">
<p><a name="yav"></a><code class="command">yav(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Average along a grid column
<div class=jython>
YAV (S) = ( S (Y1) + S (Y2) + ... + S (KYD) ) / KNT
KYD = number of points in column
KNT = number of non-missing points in column
</div></p>
<meta name="jhid" value="ysum">
<p><a name="ysum"></a><code class="command">ysum(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Sum along a grid column
<div class=jython>
YSUM (S) = ( S (Y1) + S (Y2) + ... + S (KYD) )
KYD = number of points in row
YSUM for a column is stored at every point in that column.
</div></p>
<meta name="jhid" value="zav">
<p><a name="zav"></a><code class="command">zav(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Average across the levels of a grid at all points
<div class=jython>
ZAV (S) = ( S (Z1) + S (Z2) + ... + S (KZD) ) / KNT
KZD = number of levels
KNT = number of non-missing points in column
</div></p>
<meta name="jhid" value="zsum">
<p><a name="zsum"></a><code class="command">zsum(S):</code><p style="padding:0;margin-left:20;margin-top:0">
Sum across the levels of a grid at all points
<div class=jython>
ZSUM (S) = ( S (Z1) + S (Z2) + ... + S (KZD) )
KYD = number of levels
ZSUM for a vertical column is stored at every point
</div></p>
<a name="ensemble">
<h2> Module: ensemble</h2>
 This is the doc for the ensemble grid module 
<hr>

<meta name="jhid" value="ens_mode">
<p><a name="ens_mode"></a><code class="command">ens_mode(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
mode value</p>
<meta name="jhid" value="ens_prcntl">
<p><a name="ens_prcntl"></a><code class="command">ens_prcntl(grid, percent):</code><p style="padding:0;margin-left:20;margin-top:0">
percentile value</p>
<meta name="jhid" value="ens_savg">
<p><a name="ens_savg"></a><code class="command">ens_savg(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
basic ensemble average</p>
<meta name="jhid" value="ens_smax">
<p><a name="ens_smax"></a><code class="command">ens_smax(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
max value of all member</p>
<meta name="jhid" value="ens_smin">
<p><a name="ens_smin"></a><code class="command">ens_smin(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
min value of all member</p>
<meta name="jhid" value="ens_srng">
<p><a name="ens_srng"></a><code class="command">ens_srng(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
max - min grid value</p>
<meta name="jhid" value="ens_ssprd">
<p><a name="ens_ssprd"></a><code class="command">ens_ssprd(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
basic ensemble average</p>
<meta name="jhid" value="ens_uprob">
<p><a name="ens_uprob"></a><code class="command">ens_uprob(grid, logicalOp1, pValue1, and_or, logicalOp2, pValue2, exptdLoBound, exptdUpBound):</code><p style="padding:0;margin-left:20;margin-top:0">
ensemble univariate probability calculation</p>
<a name="image">
<h2> Module: image</h2>
<hr>

<meta name="jhid" value="combineRGB">
<p><a name="combineRGB"></a><code class="command">combineRGB(red, green, blue):</code><p style="padding:0;margin-left:20;margin-top:0">
combine 3 images as an RGB image</p>
<meta name="jhid" value="makeNavigatedImage">
<p><a name="makeNavigatedImage"></a><code class="command">makeNavigatedImage(d, ulLat, ulLon, lrLat, lrLon):</code><p style="padding:0;margin-left:20;margin-top:0">
This takes a image data object and a lat/lon bounding box
and adds a lat/lon domain to the data. Use it in conjunction with a formula:</p>
<a name="climate">
<h2> Module: climate</h2>
 
   This is the doc for the climate module.  These functions are useful
   for creating climate features from grids (means, anomalies, standard
   deviations).  Function names are based on NCL function names.

<hr>

<meta name="jhid" value="calcDayAnom">
<p><a name="calcDayAnom"></a><code class="command">calcDayAnom(daily, ltm, asPercent):</code><p style="padding:0;margin-left:20;margin-top:0">
Calculate the daily anomaly from a long term mean. <br>
grid - daily values <br>
ltm  - long term mean (climatology) <br>
asPercent - if 1, return percentage of climatology normal (+/-) <br></p>
<meta name="jhid" value="calcMonAnom">
<p><a name="calcMonAnom"></a><code class="command">calcMonAnom(monthly, ltm, normalize):</code><p style="padding:0;margin-left:20;margin-top:0">
Calculate the monthly anomaly from a long term mean.
The number of timesteps in ltm must be 12 and the monthly
data must start in January.</p>
<meta name="jhid" value="clmDay">
<p><a name="clmDay"></a><code class="command">clmDay(grid, use366):</code><p style="padding:0;margin-left:20;margin-top:0">
Create a daily climatology from a grid of daily data over a period
of years.</p>
<meta name="jhid" value="clmMon">
<p><a name="clmMon"></a><code class="command">clmMon(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
Create a monthly climatology from a grid of monthly data over a period
of years. The number of timesteps must be a multiple of 12.</p>
<meta name="jhid" value="stdMon">
<p><a name="stdMon"></a><code class="command">stdMon(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
Create monthly standard deviations from a grid of monthly data over
a period of years. The number of timesteps must be a multiple of 12.</p>
<a name="maps">
<h2> Module: maps</h2>
<hr>

<meta name="jhid" value="applyFunctionToValuesInField">
<p><a name="applyFunctionToValuesInField"></a><code class="command">applyFunctionToValuesInField(function, field, min, max, inside):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="applyFunctionToValuesInRange">
<p><a name="applyFunctionToValuesInRange"></a><code class="command">applyFunctionToValuesInRange(function, range, timeStep, min, max, inside):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="applyToIndices">
<p><a name="applyToIndices"></a><code class="command">applyToIndices(function, range, timeStep, indices):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="averageFromMap">
<p><a name="averageFromMap"></a><code class="command">averageFromMap(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="averageFromMapAndClip">
<p><a name="averageFromMapAndClip"></a><code class="command">averageFromMapAndClip(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="filterMaps">
<p><a name="filterMaps"></a><code class="command">filterMaps(mapSets, propName, operator, value):</code><p style="padding:0;margin-left:20;margin-top:0">
Return a new set of maps whose property propName satisfies the given operator/value.
The operators can be ==,!=, <,>,<=,>=, match, !match</p>
<meta name="jhid" value="getMapProperty">
<p><a name="getMapProperty"></a><code class="command">getMapProperty(polygon, propName):</code><p style="padding:0;margin-left:20;margin-top:0">
Get the named property from the given mapData</p>
<meta name="jhid" value="getMapsWithProperty">
<p><a name="getMapsWithProperty"></a><code class="command">getMapsWithProperty(mapSets, propName, value):</code><p style="padding:0;margin-left:20;margin-top:0">
Return a new set of maps that have the given property value</p>
<meta name="jhid" value="make3DMap">
<p><a name="make3DMap"></a><code class="command">make3DMap(map, topo):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a 3d map. map -  map line data - topo - topography dataset</p>
<meta name="jhid" value="makeFieldFromMapBounds">
<p><a name="makeFieldFromMapBounds"></a><code class="command">makeFieldFromMapBounds(mapSets, length1, length2, fill, unit):</code><p style="padding:0;margin-left:20;margin-top:0">
Make a field whos lat/lon area is the bounds of the given mapSet. It has length1 points in the x and length2 in the y.
Fill it with the fill value and the given unit</p>
<meta name="jhid" value="mapsAbsoluteValue">
<p><a name="mapsAbsoluteValue"></a><code class="command">mapsAbsoluteValue(originalValues, newValues, indexArray):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="mapsApplyToField">
<p><a name="mapsApplyToField"></a><code class="command">mapsApplyToField(function, field, mapSets, inside):</code><p style="padding:0;margin-left:20;margin-top:0">
mapSets defines a set of polygons. This procedure fills the areas in the field are enclosed
by each polygon with the average value within that area</p>
<meta name="jhid" value="mapsApplyToRange">
<p><a name="mapsApplyToRange"></a><code class="command">mapsApplyToRange(function, range, timeStep, mapSets, inside):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="mapsAverage">
<p><a name="mapsAverage"></a><code class="command">mapsAverage(originalValues, newValues, indexArray):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="mapsMax">
<p><a name="mapsMax"></a><code class="command">mapsMax(originalValues, newValues, indexArray, value):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="mapsMin">
<p><a name="mapsMin"></a><code class="command">mapsMin(originalValues, newValues, indexArray, value):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="mapsSetValue">
<p><a name="mapsSetValue"></a><code class="command">mapsSetValue(originalValues, newValues, indexArray, value):</code><p style="padding:0;margin-left:20;margin-top:0">
</p>
<meta name="jhid" value="subsetFromMap">
<p><a name="subsetFromMap"></a><code class="command">subsetFromMap(field, mapSets, fillValue, inverse):</code><p style="padding:0;margin-left:20;margin-top:0">
mapSets defines a set of polygons. This procedure fills the areas in the field that are not
enclosed by the polygons with the fill value. If inverse is 1 then it fills the areas that are
enclosed</p>
<meta name="jhid" value="subsetRangeFromMap">
<p><a name="subsetRangeFromMap"></a><code class="command">subsetRangeFromMap(range, timeStep, mapSets, fillValue, inverse):</code><p style="padding:0;margin-left:20;margin-top:0">
mapSets defines a set of polygons. This procedure fills the areas in the field that are not
enclosed by the polygons with the fill value. If inverse is 1 then it fills the areas that are
enclosed</p>
<meta name="jhid" value="subsetRangeWithProperty">
<p><a name="subsetRangeWithProperty"></a><code class="command">subsetRangeWithProperty(range, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
test code</p>
<meta name="jhid" value="subsetWithProperty">
<p><a name="subsetWithProperty"></a><code class="command">subsetWithProperty(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
test code</p>
<meta name="jhid" value="testIndexToLatLon">
<p><a name="testIndexToLatLon"></a><code class="command">testIndexToLatLon(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
Test out the GridUtil.getLatLons method. Call this with some grid field and a set of maps</p>
<meta name="jhid" value="testIndexToLatLon2">
<p><a name="testIndexToLatLon2"></a><code class="command">testIndexToLatLon2(field, mapSets):</code><p style="padding:0;margin-left:20;margin-top:0">
Test out the GridUtil.getLatLons method. Call this with some grid field and a set of maps</p>
<a name="shell">
<h2> Module: shell</h2>
A set of utilities for selecting data and creating displays.
   For use from the Jython shell.
<hr>

<meta name="jhid" value="clear">
<p><a name="clear"></a><code class="command">clear():</code><p style="padding:0;margin-left:20;margin-top:0">
Clear the shell</p>
<meta name="jhid" value="createDisplay">
<p><a name="createDisplay"></a><code class="command">createDisplay(displayType, data, dataName):</code><p style="padding:0;margin-left:20;margin-top:0">
create a display of type displayType. Right click in input field to select particular displayType.
The data is can be a data object, a datachoice or a list of data or datachoices
The dataName is used to name the data, i.e., its the parameter name</p>
<meta name="jhid" value="findDataSource">
<p><a name="findDataSource"></a><code class="command">findDataSource(name):</code><p style="padding:0;margin-left:20;margin-top:0">
Find the data source object with the given name. If no name is given then this will return the first (non-formula)
data source</p>
<meta name="jhid" value="getData">
<p><a name="getData"></a><code class="command">getData(dataSourceName, dataChoiceName):</code><p style="padding:0;margin-left:20;margin-top:0">
Find the data source with the given name and the data choice on that data source with the given name.
If no dataSourceName is given then use the first one in the list
If no dataChoiceName is given then use the first one held by the data source
Return the data for the data choice.
If no data source or data choice is found then return null</p>
<meta name="jhid" value="getDataChoice">
<p><a name="getDataChoice"></a><code class="command">getDataChoice(dataSourceName, dataChoiceName):</code><p style="padding:0;margin-left:20;margin-top:0">
Find the data source with the given name and the data choice on that data source with the given name.
If no dataSourceName is given then use the first one in the list
If no dataChoiceName is given then use the first one held by the data source
Return the data choice
If no data source or data choice is found then return null</p>
<meta name="jhid" value="listVars">
<p><a name="listVars"></a><code class="command">listVars():</code><p style="padding:0;margin-left:20;margin-top:0">
List all of the variables defined in the shell's interpreter</p>
<meta name="jhid" value="makeDataSource">
<p><a name="makeDataSource"></a><code class="command">makeDataSource(path, type):</code><p style="padding:0;margin-left:20;margin-top:0">
Create a datasource from the given file name or url. The optional type parameter
is used to specify the type of data</p>
<meta name="jhid" value="printType">
<p><a name="printType"></a><code class="command">printType(data):</code><p style="padding:0;margin-left:20;margin-top:0">
Print out the math type of the given data</p>
<meta name="jhid" value="selectData">
<p><a name="selectData"></a><code class="command">selectData(name1, name2, name3, name4, name5):</code><p style="padding:0;margin-left:20;margin-top:0">
Select up to 5 data fields. This returns a List of the actual Data objects</p>
<meta name="jhid" value="selectDataChoice">
<p><a name="selectDataChoice"></a><code class="command">selectDataChoice(name1, name2, name3, name4, name5):</code><p style="padding:0;margin-left:20;margin-top:0">
Select up to 5 data choices. This returns a List of the data choices, not the actual Data
To get the data do:   <div class=jython>dataList.get(0).getData(None)</div></p>
<meta name="jhid" value="setDataChoices">
<p><a name="setDataChoices"></a><code class="command">setDataChoices(dataSource):</code><p style="padding:0;margin-left:20;margin-top:0">
The given dataSource can be an actual data source or the name of a data source.
This procedure will define a set of jython variables that correspond to the data choices
held by the given data source.</p>
<meta name="jhid" value="setDataSources">
<p><a name="setDataSources"></a><code class="command">setDataSources():</code><p style="padding:0;margin-left:20;margin-top:0">
This procedure will define a set of jython variables, 'dataSource0, dataSource1, ...'  that correspond to
loaded data sources.</p>
<meta name="jhid" value="showLib">
<p><a name="showLib"></a><code class="command">showLib():</code><p style="padding:0;margin-left:20;margin-top:0">
Bring up the jython library dialog</p>
<a name="misc">
<h2> Module: misc</h2>
A set of miscellaneous utilities. 
<hr>

<meta name="jhid" value="cloneArray">
<p><a name="cloneArray"></a><code class="command">cloneArray(array):</code><p style="padding:0;margin-left:20;margin-top:0">
A utility to make a 2 dimensional float array filled
with the given value</p>
<meta name="jhid" value="idveval">
<p><a name="idveval"></a><code class="command">idveval(formula):</code><p style="padding:0;margin-left:20;margin-top:0">
evaluate a formula  and return a DerivedDataChoice</p>
<meta name="jhid" value="makeFloatArray">
<p><a name="makeFloatArray"></a><code class="command">makeFloatArray(rows, cols, value):</code><p style="padding:0;margin-left:20;margin-top:0">
A utility to make a 2 dimensional float array filled
with the given value</p>
<meta name="jhid" value="printSounding">
<p><a name="printSounding"></a><code class="command">printSounding(sounding):</code><p style="padding:0;margin-left:20;margin-top:0">
Print out the values of the sounding data</p>
<meta name="jhid" value="printSoundings">
<p><a name="printSoundings"></a><code class="command">printSoundings(d):</code><p style="padding:0;margin-left:20;margin-top:0">
Print out the values of the set of sounding data</p>


<h2> Module: ML Preprocessing</h2>
A suite of tools for transforming raw datasets, making them suitable for applications like machine learning.
<hr>
   <meta name="jhid" value="gridNormalizer">
   <p><a name="gridNormalizer"></a><code class="command">gridNormalizer(grid, user_norm):</code><p style="padding:0;margin-left:20;margin-top:0">
   Normalize samples individually to unit norm.
   Each sample (i.e. each row of the data matrix) with at least one non zero component
   is rescaled independently of other samples so that its norm (l1, l2 or inf) equals one. The default user_norm is set
   to Max.</p>
   <meta name="jhid" value="gridRobustScaler">
   <p><a name="gridRobustScaler"></a><code class="command">gridRobustScaler(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
   Rescale the grid values individually to a common range (user_min, user_max) linearly using statistics and
   it is also known as min-max normalization
   This Scaler removes the median and scales the data according to the quantile range
   (defaults to IQR: Interquartile Range). The IQR is the range between the 1st quartile (25th quantile) and
   the 3rd quartile (75th quantile).
   However, outliers can often influence the sample mean/variance in a negative way. In such cases,
   using the median and the interquartile range often give better results.</p>
   <meta name="jhid" value="gridMinMaxScaler">
   <p><a name="gridMinMaxScaler"></a><code class="command">gridMinMaxScaler(grid,user_min,user_max):</code><p style="padding:0;margin-left:20;margin-top:0">
   Rescale the grid values individually to a common range (user_min, user_max) linearly using statistics and
   it is also known as min-max normalization. It doesn’t reduce the effect of outliers, but it linearly scales
   them down into a fixed range, where the largest occurring data point corresponds to the maximum value
   and the smallest one corresponds to the minimum value.</p>
   <meta name="jhid" value="gridStandardScaler">
   <p><a name="gridStandardScaler"></a><code class="command">gridStandardScaler(grid,user_mean=None,user_std=None):</code><p style="padding:0;margin-left:20;margin-top:0">
   StandardScaler standardizes grid values by removing the mean and scaling to
   variance using statistics on the samples to improve the performance and
   convergence of machine learning models, particularly those sensitive to
   feature scales. It is sensitive to outliers, and the features may scale
   differently from each other in the presence of outliers.</p>
   <meta name="jhid" value="gridPowerTransform">
   <p><a name="gridPowerTransform"></a><code class="command">gridPowerTransform(grid, user_lambda):</code><p style="padding:0;margin-left:20;margin-top:0">
   Power transforms are a family of parametric, monotonic transformations that are applied
   to make data more Gaussian-like. This is useful for modeling issues related to
   heteroscedasticity (non-constant variance), or other situations where normality is desired.
   Currently, power_transform supports the Yeo-Johnson transform and Yeo-Johnson supports
   both positive or negative data.</p>
   <meta name="jhid" value="gridQuantileTransform">
   <p><a name="gridQuantileTransform"></a><code class="command">gridQuantileTransform(grid):</code><p style="padding:0;margin-left:20;margin-top:0">
   Rescale the grid values individually to a common range (user_min, user_max) linearly using statistics and
   it is also known as min-max normalization.</p>
   <meta name="jhid" value="gridPowerTransform">
   <p><a name="gridPowerTransform"></a><code class="command">gridPowerTransform(grid, user_lambda):</code><p style="padding:0;margin-left:20;margin-top:0">
   Power transforms are a family of parametric, monotonic transformations that are applied
   to make data more Gaussian-like. This is useful for modeling issues related to
   heteroscedasticity (non-constant variance), or other situations where normality is desired.
   Currently, power_transform supports the Yeo-Johnson transform and Yeo-Johnson supports
   both positive or negative data.</p>

   <meta name="jhid" value="gridUniformDistribution">
   <p><a name="gridUniformDistribution"></a><code class="command">gridUniformDistribution(grid,user_min=None,user_max=None):</code><p style="padding:0;margin-left:20;margin-top:0">
   Returns a grid with values sampled from uniform distrubuition(
   user_min,user_max). user_units can be change units of returned grid.
   This also serves as a template code for creating grids sampled from
   different distributions.</p>
   <meta name="jhid" value="medianFilter">
   <p><a name="medianFilter"></a><code class="command">medianFilter(grid, user_missingValue=None, window_lenx=10, window_leny=10):</code><p style="padding:0;margin-left:20;margin-top:0">
   calculate median filter, need to replace the missingValue if it is not NaN.</p>
   <meta name="jhid" value="classifier">
   <p><a name="classifier"></a><code class="command">classifier(grid, classifierStr, outFileName):</code><p style="padding:0;margin-left:20;margin-top:0">
   classifierStr is a string of a set of classifier info with format:
   low1 high1 value1; low2 high2 value2; low3 high3 value3;....</p>
   <meta name="jhid" value="applyFunctionOverGrid2D-Average">
   <p><a name="applyFunctionOverGrid2D-Average"></a><code class="command">applyFunctionOverGrid2D(grid, "average", "none"):</code><p style="padding:0;margin-left:20;margin-top:0">
   Apply spatial Average over 2D grid and return time series point data.</p>
   <meta name="jhid" value="applyFunctionOverGrid2D-Max">
   <p><a name="applyFunctionOverGrid2D-Max"></a><code class="command">applyFunctionOverGrid2D(grid, "max", "none"):</code><p style="padding:0;margin-left:20;margin-top:0">
   Apply spatial Max over 2D grid and return time series point data.</p>
   <meta name="jhid" value="applyFunctionOverGrid2D-Min">
   <p><a name="applyFunctionOverGrid2D-Min"></a><code class="command">applyFunctionOverGrid2D(grid, "min", "none"):</code><p style="padding:0;margin-left:20;margin-top:0">
   Apply spatial Min over 2D grid and return time series point data.</p>
   <meta name="jhid" value="applyFunctionOverGrid2D-Percentile">
   <p><a name="applyFunctionOverGrid2D-Percentile"></a><code class="command">applyFunctionOverGrid2D(grid, "percentile", user_statThreshold):</code><p style="padding:0;margin-left:20;margin-top:0">
   Apply spatial Average over 2D grid and return time series point data.</p>
   <meta name="jhid" value="exportTimeSeriesToCSV">
   <p><a name="exportTimeSeriesToCSV"></a><code class="command">exportTimeSeriesToCSV(field,file\[type=file,isuser=true,label=csv File,filepattern=.csv:CSV Files\]):</code><p style="padding:0;margin-left:20;margin-top:0">
   Export Point Time Series to CSV.</p>
   <meta name="jhid" value="exportTimeSeriesToExcel">
   <p><a name="exportTimeSeriesToExcel"></a><code class="command">exportTimeSeriesToCSV(field,file\[type=file,isuser=true,label=Excel File,filepattern=.xls:Excel Files\]):</code><p style="padding:0;margin-left:20;margin-top:0">
   Export Point Time Series to Excel.</p>



[ug::foot]
